{"version":3,"sources":["service-worker.ts"],"names":["self","__WB_MANIFEST","VERSION","addEventListener","event","console","log","concat","skipWaiting","waitUntil","async","cache","caches","open","addAll","resources","addResourcesToCache","process","cacheNames","keys","Promise","all","filter","item","map","delete","deleteOld","respondWith","responseFromCache","match","request","responseFromNetwork","fetch","response","method","put","storeInCache","clone","cacheFirst","data","type"],"mappings":"mBAMgB,oPAAK,cAArB,MAKM,EAAU,kBAGhB,KAAK,iBAAiB,WAAY,IAChC,QAAQ,IAAI,GAAD,OAAI,EAAO,sBAatB,KAAK,cAEL,EAAM,UAPsB,WAC1B,MAAM,QAAc,OAAO,KAAK,SAC1B,EAAM,OAAO,EAAU,EAKf,CAbC,CACf,8BACA,wCACA,6CAU4C,IAGhD,KAAK,iBAAiB,YAAa,IAQjC,EAAM,UAPY,WAChB,MAAM,QAAmB,OAAO,aAE1B,QAAQ,IAAI,EAAW,QAAQ,GAAS,IAAS,IAAS,KAAK,GAAS,OAAO,OAAO,KAAO,EAIrF,IAEhB,QAAQ,IAAI,GAAD,OAAI,EAAO,iBAAgB,IAGxC,KAAK,iBAAiB,SAAU,IA2B9B,EAAM,YAfa,WAEjB,MAAM,QAA0B,OAAO,MAAM,GAC7C,GAAI,EACF,OAAO,EAIT,MAAM,QAA4B,MAAM,GAIxC,MAvBmB,OAAO,EAAkB,KAC5C,MAAM,QAAc,OAAO,KAAK,GAET,SAAnB,EAAQ,aAKN,EAAM,IAAI,EAAS,GAJvB,QAAQ,IAAI,6BAIoB,EAclC,CAAa,EAAS,EAAoB,SACnC,CAAmB,EAGV,CAAW,EAAM,SAAS,IAK9C,KAAK,iBAAiB,WAAY,IAC5B,EAAM,MAA4B,iBAApB,EAAM,KAAK,MAC3B,KAAK,aACP","file":"service-worker.js","sourceRoot":"","sourcesContent":["/// <reference lib=\"webworker\" />\n/* eslint-disable no-restricted-globals */\n\nimport { precacheAndRoute } from \"workbox-precaching\";\n\ndeclare const self: ServiceWorkerGlobalScope;\nconst ignored = self.__WB_MANIFEST;\n// clientsClaim();\n\n// precacheAndRoute(self.__WB_MANIFEST);\n\nconst VERSION = \"v1.0.0-testing1\";\n\n// Create a base cache on Install\nself.addEventListener(\"install\", (event) => {\n  console.log(`${VERSION} installingâ€¦`);\n\n  const fileList = [\n    process.env.PUBLIC_URL + \"/\",\n    process.env.PUBLIC_URL + \"/index.html\",\n    process.env.PUBLIC_URL + \"/manifest.json\",\n  ];\n\n  const addResourcesToCache = async (resources: string[]) => {\n    const cache = await caches.open(VERSION);\n    await cache.addAll(resources);\n  };\n\n  self.skipWaiting();\n\n  event.waitUntil(addResourcesToCache(fileList));\n});\n\nself.addEventListener(\"activate\", (event) => {\n  const deleteOld = async () => {\n    const cacheNames = await caches.keys();\n\n    await Promise.all(cacheNames.filter((item) => item !== VERSION).map((item) => caches.delete(item)));\n  };\n\n  // Delete all old caches after taking control\n  event.waitUntil(deleteOld());\n\n  console.log(`${VERSION} activated...`);\n});\n\nself.addEventListener(\"fetch\", (event) => {\n  const storeInCache = async (request: Request, response: Response) => {\n    const cache = await caches.open(VERSION);\n\n    if (request.method === \"POST\") {\n      console.log(\"Cannot cache POST requests\");\n      return;\n    }\n\n    await cache.put(request, response);\n  };\n\n  const cacheFirst = async (request: Request) => {\n    // First, Service Worker will retrieve the asset from the cache\n    const responseFromCache = await caches.match(request);\n    if (responseFromCache) {\n      return responseFromCache;\n    }\n\n    // If not present in the cache it will call the APIs\n    const responseFromNetwork = await fetch(request);\n\n    // Then store them in the cache\n    storeInCache(request, responseFromNetwork.clone());\n    return responseFromNetwork;\n  };\n\n  event.respondWith(cacheFirst(event.request));\n});\n\n// This allows the web app to trigger skipWaiting via\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\nself.addEventListener(\"message\", (event) => {\n  if (event.data && event.data.type === \"SKIP_WAITING\") {\n    self.skipWaiting();\n  }\n});\n"]}