{"version":3,"sources":["service-worker.ts"],"names":["VERSION","self","addEventListener","event","console","log","concat","fileList","__WB_MANIFEST","skipWaiting","waitUntil","async","cache","caches","open","addAll","resources","map","r","url","addResourcesToCache","cacheNames","keys","Promise","all","filter","item","delete","deleteOld","respondWith","responseFromCache","match","request","responseFromNetwork","fetch","response","method","put","storeInCache","clone","cacheFirst","storeName","data","action","expense","callback","db","indexedDB","onerror","_event$target","target","errorCode","onupgradeneeded","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","_event$target2","openDB","transaction","objectStore","error","oncomplete","close","addToStore","tag"],"mappings":"mBAOA,MAAM,EAAU,kBAGhB,KAAK,iBAAiB,WAAY,IAChC,QAAQ,IAAI,GAAD,OAAI,EAAO,sBAEtB,MAAM,EAAW,oPAAK,cAOtB,KAAK,cAEL,EAAM,UAPsB,WAC1B,MAAM,QAAc,OAAO,KAAK,SAC1B,EAAM,OAAO,EAAU,KAAK,GAAM,EAAE,MAAK,EAKjC,CAAoB,GAAU,IAGhD,KAAK,iBAAiB,YAAa,IAQjC,EAAM,UAPY,WAChB,MAAM,QAAmB,OAAO,aAE1B,QAAQ,IAAI,EAAW,QAAQ,GAAS,IAAS,IAAS,KAAK,GAAS,OAAO,OAAO,KAAO,EAIrF,IAEhB,QAAQ,IAAI,GAAD,OAAI,EAAO,iBAAgB,IAGxC,KAAK,iBAAiB,SAAU,IA2B9B,EAAM,YAfa,WAEjB,MAAM,QAA0B,OAAO,MAAM,GAC7C,GAAI,EACF,OAAO,EAIT,MAAM,QAA4B,MAAM,GAIxC,MAvBmB,OAAO,EAAkB,KAC5C,MAAM,QAAc,OAAO,KAAK,GAET,SAAnB,EAAQ,aAKN,EAAM,IAAI,EAAS,GAJvB,QAAQ,IAAI,6BAIoB,EAclC,CAAa,EAAS,EAAoB,SACnC,CAAmB,EAGV,CAAW,EAAM,SAAS,IAI9C,MAEM,EAAY,YAkFlB,KAAK,iBAAiB,WAAY,IAChC,IAAK,EAAM,MAA8B,oBAAtB,EAAM,KAAK,OAC5B,OAGF,MAAM,EAAU,EAAM,KAAK,MApF7B,eAAsB,GACpB,IAAI,EACJ,MAAM,EAAU,KAAK,UAAU,KAPlB,cACC,GAQd,EAAQ,QAAU,SAAU,GAAe,IAAD,EACxC,QAAQ,IAAI,+CAA6D,QAAhB,EAAI,EAAM,cAAM,IAAA,OAAA,EAAb,EAAuB,WACrF,EAEA,EAAQ,gBAAkB,SAAU,GAClC,EAAK,EAAQ,OAER,EAAG,iBAAiB,SAAS,IAChC,EAAG,kBAAkB,EAAW,CAAE,QAAS,MAE/C,EAEA,EAAQ,UAAY,SAAU,GAAQ,IAAD,EACnC,EAAkB,QAAhB,EAAI,EAAM,cAAM,IAAA,OAAA,EAAb,EAAuB,OACxB,GACF,EAAS,EAEb,CACF,CAgEE,EAAQ,GA9DV,eAA0B,EAAiB,GAEzC,MAAM,EAAc,EAAG,YAAY,EAAW,aAMxC,EAHQ,EAAY,YAAY,GAGhB,IAAI,GAE1B,EAAQ,UAAY,WAClB,QAAQ,IAAI,qBAAsB,EAAS,EAAQ,OACrD,EAEA,EAAQ,QAAU,WAChB,QAAQ,IAAI,8BAA+B,EAAQ,MACrD,EAEA,EAAY,QAAU,SAAU,GAC9B,QAAQ,IAAI,eAAgB,EAC9B,EAEA,EAAY,WAAa,SAAU,GACjC,QAAQ,IAAI,kBAAmB,GAC/B,EAAG,OACL,CACF,CAoCiB,CAAW,EAAI,IAAS,IAIzC,KAAK,iBAAiB,QAAQ,SAAS,GACnB,iBAAd,EAAM,KACL,QAAQ,IAAI,EAEnB","file":"service-worker.js","sourceRoot":"","sourcesContent":["/// <reference lib=\"webworker\" />\n/* eslint-disable no-restricted-globals */\n\nimport { PrecacheEntry, PrecacheRoute as _ } from \"workbox-precaching\";\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst VERSION = \"v1.0.0-testing3\";\n\n// Create a base cache on Install\nself.addEventListener(\"install\", (event: ExtendableEvent) => {\n  console.log(`${VERSION} installingâ€¦`);\n\n  const fileList = self.__WB_MANIFEST as PrecacheEntry[];\n\n  const addResourcesToCache = async (resources: PrecacheEntry[]) => {\n    const cache = await caches.open(VERSION);\n    await cache.addAll(resources.map((r) => r.url));\n  };\n\n  self.skipWaiting();\n\n  event.waitUntil(addResourcesToCache(fileList));\n});\n\nself.addEventListener(\"activate\", (event: ExtendableEvent) => {\n  const deleteOld = async () => {\n    const cacheNames = await caches.keys();\n\n    await Promise.all(cacheNames.filter((item) => item !== VERSION).map((item) => caches.delete(item)));\n  };\n\n  // Delete all old caches after taking control\n  event.waitUntil(deleteOld());\n\n  console.log(`${VERSION} activated...`);\n});\n\nself.addEventListener(\"fetch\", (event: FetchEvent) => {\n  const storeInCache = async (request: Request, response: Response) => {\n    const cache = await caches.open(VERSION);\n\n    if (request.method === \"POST\") {\n      console.log(\"Cannot cache POST requests\");\n      return;\n    }\n\n    await cache.put(request, response);\n  };\n\n  const cacheFirst = async (request: Request) => {\n    // First, Service Worker will retrieve the asset from the cache\n    const responseFromCache = await caches.match(request);\n    if (responseFromCache) {\n      return responseFromCache;\n    }\n\n    // If not present in the cache it will call the APIs\n    const responseFromNetwork = await fetch(request);\n\n    // Then store them in the cache\n    storeInCache(request, responseFromNetwork.clone());\n    return responseFromNetwork;\n  };\n\n  event.respondWith(cacheFirst(event.request));\n});\n\n// create indexedDB variables:\nconst dbName = \"expenses-db\";\nconst version = 1;\nconst storeName = \"exp-store\";\ntype callback = (data?: any) => void;\n\nasync function openDB(callback: callback) {\n  let db: IDBDatabase;\n  const request = self.indexedDB.open(dbName, version);\n\n  request.onerror = function (event: Event) {\n    console.log(\"ExpenseApp isn't allowed to use IndexedDB?!\" + (event.target as any)?.errorCode);\n  };\n\n  request.onupgradeneeded = function (event: Event) {\n    db = request.result;\n\n    if (!db.objectStoreNames.contains(storeName)) {\n      db.createObjectStore(storeName, { keyPath: \"id\" });\n    }\n  };\n\n  request.onsuccess = function (event) {\n    db = (event.target as any)?.result;\n    if (callback) {\n      callback(db);\n    }\n  };\n}\n\nasync function addToStore(db: IDBDatabase, expense: any) {\n  // start a transaction\n  const transaction = db.transaction(storeName, \"readwrite\");\n\n  // create an object store\n  const store = transaction.objectStore(storeName);\n\n  // add key and value to the store\n  const request = store.put(expense);\n\n  request.onsuccess = function () {\n    console.log(\"added to the store\", expense, request.result);\n  };\n\n  request.onerror = function () {\n    console.log(\"Error did not save to store\", request.error);\n  };\n\n  transaction.onerror = function (event) {\n    console.log(\"trans failed\", event);\n  };\n\n  transaction.oncomplete = function (event) {\n    console.log(\"trans completed\", event);\n    db.close();\n  };\n}\n\n// async function getFromStore(id: string, callback: callback) {\n//   // start a transaction\n//   const transaction = db.transaction(storeName, \"readwrite\");\n//   // create an object store\n//   const store = transaction.objectStore(storeName);\n\n//   // get key and value from the store\n//   const request = store.get(id);\n\n//   request.onsuccess = function (event) {\n//     if (callback) {\n//       callback((event.target as any)?.result.value);\n//     }\n//   };\n//   request.onerror = function () {\n//     console.log(\"Error did not read to store\", request.error);\n//   };\n\n//   transaction.onerror = function (event) {\n//     console.log(\"trans failed\", event);\n//   };\n\n//   transaction.oncomplete = function (event) {\n//     console.log(\"trans completed\", event);\n//   };\n// }\n\nself.addEventListener(\"message\", (event) => {\n  if (!event.data || event.data.action !== \"ADD_NEW_EXPENSE\") {\n    return;\n  }\n\n  const expense = event.data.data;\n\n  openDB((db) => addToStore(db, expense));\n});\n\n\nself.addEventListener(\"sync\", function(event) {\n  if (event.tag === \"expense-sync\") {\n       console.log(event)\n  }\n});"]}