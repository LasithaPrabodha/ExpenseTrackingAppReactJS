{"version":3,"sources":["lib/indexdb-manager.ts","service-worker.ts"],"names":["IndexDbManager","openDB","callback","db","request","indexedDB","open","this","expDbName","version","onerror","event","_event$target","console","log","target","errorCode","onupgradeneeded","result","objectStoreNames","contains","expStoreName","createObjectStore","keyPath","onsuccess","_event$target2","addToStore","expense","storeName","arguments","length","undefined","transaction","store","objectStore","Array","isArray","forEach","e","addToDb","oncomplete","close","put","error","getFromStore","Promise","resolve","reject","getAll","_event$target3","catStoreName","VERSION","self","addEventListener","concat","fileList","__WB_MANIFEST","skipWaiting","waitUntil","async","cache","caches","addAll","resources","map","r","url","addResourcesToCache","cacheNames","keys","all","filter","item","delete","deleteOld","respondWith","responseFromCache","match","responseFromNetwork","fetch","response","method","includes","process","storeInCache","clone","cacheFirst","tag","channelE","BroadcastChannel","then","expenses","postMessage","channelC","categories"],"mappings":"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","file":"service-worker.js","sourceRoot":"","sourcesContent":["type callback = (data?: any) => void;\n\nexport default class IndexDbManager {\n  private static expDbName = \"expenses-db\";\n  private static version = 1;\n  public static expStoreName = \"exp-store\";\n  public static catStoreName = \"cat-store\";\n\n  static openDB(callback: callback) {\n    let db: IDBDatabase;\n    const request = indexedDB.open(this.expDbName, this.version);\n\n    request.onerror = (event: Event) => {\n      console.log(\"ExpenseApp isn't allowed to use IndexedDB?!\" + (event.target as any)?.errorCode);\n    };\n\n    request.onupgradeneeded = (event: Event) => {\n      db = request.result;\n\n      if (!db.objectStoreNames.contains(this.expStoreName)) {\n        db.createObjectStore(this.expStoreName, { keyPath: \"id\" });\n      }\n    };\n\n    request.onsuccess = (event) => {\n      db = (event.target as any)?.result;\n\n      callback && callback(db);\n    };\n  }\n\n  static addToStore(expense: any, storeName: string = this.expStoreName) {\n    this.openDB((db) => {\n      // start a transaction\n      const transaction = db.transaction(storeName, \"readwrite\");\n\n      // create an object store\n      const store = transaction.objectStore(storeName);\n\n      if (Array.isArray(expense)) {\n        expense.forEach((e) => this.addToDb(store, e));\n      } else {\n        this.addToDb(store, expense);\n      }\n\n      transaction.onerror = function (event: Event) {\n        console.log(\"transaction failed\", event);\n      };\n\n      transaction.oncomplete = (event: Event) => {\n        db.close();\n      };\n    });\n  }\n\n  private static addToDb(store: any, expense: any) {\n    // add key and value to the store\n    const request = store.put(expense);\n\n    request.onerror = function () {\n      console.log(\"Error did not save to store\", request.error);\n    };\n  }\n\n  static getFromStore(storeName: string = this.expStoreName) {\n    return new Promise((resolve, reject) => {\n      this.openDB((db) => {\n        // start a transaction\n        const transaction = db.transaction(storeName, \"read\");\n        // create an object store\n        const store = transaction.objectStore(storeName);\n\n        // get key and value from the store\n        const request = store.getAll();\n\n        request.onsuccess = function (event: Event) {\n          resolve((event.target as any)?.result);\n        };\n        request.onerror = function () {\n          console.log(\"Error did not read to store\", request.error);\n        };\n\n        transaction.onerror = function (event: Event) {\n          console.log(\"transaction failed\", event);\n        };\n      });\n    });\n  }\n}\n","/// <reference lib=\"webworker\" />\n/* eslint-disable no-restricted-globals */\n\nimport { PrecacheEntry, PrecacheRoute as _ } from \"workbox-precaching\";\nimport IndexDbManager from \"./lib/indexdb-manager\";\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst VERSION = \"v1.0.0-testing21\";\n\n// Create a base cache on Install\nself.addEventListener(\"install\", (event: ExtendableEvent) => {\n  console.log(`${VERSION} installingâ€¦`);\n\n  const fileList = self.__WB_MANIFEST as PrecacheEntry[];\n\n  const addResourcesToCache = async (resources: PrecacheEntry[]) => {\n    const cache = await caches.open(VERSION);\n    await cache.addAll(resources.map((r) => r.url));\n  };\n\n  self.skipWaiting();\n\n  event.waitUntil(addResourcesToCache(fileList));\n});\n\nself.addEventListener(\"activate\", (event: ExtendableEvent) => {\n  const deleteOld = async () => {\n    const cacheNames = await caches.keys();\n\n    await Promise.all(cacheNames.filter((item) => item !== VERSION).map((item) => caches.delete(item)));\n  };\n\n  // Delete all old caches after taking control\n  event.waitUntil(deleteOld());\n\n  console.log(`${VERSION} activated...`);\n});\n\nself.addEventListener(\"fetch\", (event: FetchEvent) => {\n  const storeInCache = async (request: Request, response: Response) => {\n    const cache = await caches.open(VERSION);\n\n    if (request.method === \"POST\") {\n      console.log(\"Cannot cache POST requests\");\n      return;\n    }\n\n    if (!request.url.includes(process.env.PUBLIC_URL)) {\n      console.log(\"Cannot cache 3rd party requests\");\n      return;\n    }\n\n    await cache.put(request, response);\n  };\n\n  const cacheFirst = async (request: Request) => {\n    // First, Service Worker will retrieve the asset from the cache\n    const responseFromCache = await caches.match(request);\n    if (responseFromCache) {\n      return responseFromCache;\n    }\n\n    // If not present in the cache it will call the APIs\n    const responseFromNetwork = await fetch(request);\n\n    // Then store them in the cache\n    storeInCache(request, responseFromNetwork.clone());\n    return responseFromNetwork;\n  };\n\n  event.respondWith(cacheFirst(event.request));\n});\n\nself.addEventListener(\"message\", (event) => {});\n\nself.addEventListener(\"sync\", function (event) {\n  if (event.tag === \"expense-sync\") {\n    const channelE = new BroadcastChannel(\"indexdb-expenses\");\n\n    IndexDbManager.getFromStore().then((expenses) => {\n      channelE.postMessage(expenses);\n    });\n\n    const channelC = new BroadcastChannel(\"indexdb-categories\");\n\n    IndexDbManager.getFromStore(IndexDbManager.catStoreName).then((categories) => {\n      channelC.postMessage(categories);\n    });\n  }\n});\n"]}